{\rtf1\ansi\deff1\adeflang1025
{\fonttbl{\f0\froman\fprq2\fcharset0 Nimbus Roman No9 L{\*\falt Times New Roman};}{\f1\froman\fprq2\fcharset0 Nimbus Roman No9 L{\*\falt Times New Roman};}{\f2\fswiss\fprq2\fcharset0 DejaVu Sans;}{\f3\froman\fprq2\fcharset0 Nimbus Roman No9 L{\*\falt Times New Roman};}{\f4\fswiss\fprq2\fcharset0 Nimbus Sans L{\*\falt Arial};}{\f5\fnil\fprq0\fcharset128 Nimbus Roman No9 L{\*\falt Times New Roman};}}
{\colortbl;\red0\green0\blue0;\red128\green128\blue128;}
{\stylesheet{\s1\rtlch\afs24\lang255\ltrch\dbch\af2\langfe3081\hich\fs24\lang3081\loch\fs24\lang3081\snext1 Normal;}
{\s2\sb240\sa120\keepn\rtlch\af4\afs28\lang255\ltrch\dbch\af1\langfe3081\hich\f4\fs28\lang3081\loch\f4\fs28\lang3081\sbasedon1\snext3 Heading;}
{\s3\sa120\rtlch\afs24\lang255\ltrch\dbch\af2\langfe3081\hich\fs24\lang3081\loch\fs24\lang3081\sbasedon1\snext3 Body Text;}
{\s4\sa120\rtlch\afs24\lang255\ltrch\dbch\af2\langfe3081\hich\fs24\lang3081\loch\fs24\lang3081\sbasedon3\snext4 List;}
{\s5\sb120\sa120\rtlch\afs24\lang255\ai\ltrch\dbch\af2\langfe3081\hich\fs24\lang3081\i\loch\fs24\lang3081\i\sbasedon1\snext5 caption;}
{\s6\rtlch\afs24\lang255\ltrch\dbch\af2\langfe3081\hich\fs24\lang3081\loch\fs24\lang3081\sbasedon1\snext6 Index;}
{\s7\sb120\sa120\rtlch\afs24\lang255\ai\ltrch\dbch\af2\langfe3081\hich\fs24\lang3081\i\loch\fs24\lang3081\i\sbasedon1\snext7 caption;}
{\s8\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs20\lang3081\loch\f5\fs20\lang3081\sbasedon1\snext8 Preformatted Text;}
}
{\info{\creatim\yr0\mo0\dy0\hr0\min0}{\revtim\yr0\mo0\dy0\hr0\min0}{\printim\yr0\mo0\dy0\hr0\min0}{\comment StarWriter}{\vern6800}}\deftab709
{\*\pgdsctbl
{\pgdsc0\pgdscuse195\pgwsxn11905\pghsxn16837\marglsxn1134\margrsxn1134\margtsxn1134\margbsxn1134\pgdscnxt0 Standard;}}
{\*\pgdscno0}\paperh16837\paperw11905\margl1134\margr1134\margt1134\margb1134\sectd\sbknone\pgwsxn11905\pghsxn16837\marglsxn1134\margrsxn1134\margtsxn1134\margbsxn1134\ftnbj\ftnstart1\ftnrstcont\ftnnar\aenddoc\aftnrstcont\aftnstart1\aftnnrlc
\pard\plain \ltrpar\s8\ql\rtlch\af5\afs24\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 Struktury na zapamatanie si instrukcii:}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs20\lang3081\loch\f5\fs20\lang3081 
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 \tab Mame mnozstvo funkcii, ktore treba zavolat -> zapamatne v nejakom strome pre lahsi pritup, spolu s premennymi.}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 Ked hladam funkciu -> v poslednom uzle je odkaz na strukturu, ktora drzi vsetky instrukcie, ktore sa maju vykonat, defaultne null, aby sa odlisila od toho, ked bude nahodou rovnakym menom oznacena funkcia aj premenna.}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 Chcem volat funkciu : vyhladam si  strome dane meno a zistim, ze nie je struktura NULL -> potom ju naloadujem \u8211\'3f nemiesto volania CALL skopirujem kompletne jej instrukcie na stack}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 chcem zavolat premennu (naloadovat) -> vyhladam si v strome a zistim, ci je 'aktivna', to jest bola v danom bloku deklarovan, ak nie, tak ju v danom bloku deklarujeme t.j. 'var' nam vobec netreba, lebo akonahle nejaky identifikator pouzijeme, vytvori sa a 
priradi sa mu typ podla toho, co donho nacpeme. Pricom plati, ze prvy vyskyt je rovnake ako deklarovanie, takze existuju lokalne premenne, ktore sa na konci kazdeho bloku ( \{...\} ) vymazu.}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 Loadovanie znamena, ze sa n ciselny stack prida pointer na danu strukturu premennej.}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 V pripade volania pola sa zisti to iste, akurat ze moze mat ako vedlajsi parameter cislo elementu ( v pripade viacnasobneho pola sa toto cislo dopocitava, jelokoz to v strukture ukladam ako jedno velke pole)}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 \tab Preddefinovana funkcia je funkcia main, ktora je unikatna a neprepisatelna.}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs20\lang3081\loch\f5\fs20\lang3081 
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 Co su instrukcie: }
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs20\lang3081\loch\f5\fs20\lang3081 
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 \tab Najelementarnejsie akcie, ktore sa daju vykonat, t.j. napriklad vyzdvihnutie premennej, pricitanie, ulozenie a pod.}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 \tab Poznam dva typy instrukcii :}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 \tab \tab - nepotrebuju nic (ako napriklad move, shoot, tie si svoje parametre zoberu zo }
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 \tab \tab ciselneho stacku, ktory je oddelene a obsahuje len aktualne hodnoty a mena tych \tab \tab \tab premennch, co boli naloadovane), pretoze to, co potrebuje, si musi dynamicky \tab \tab naloadovat(hodnoty inych premenncyh) }
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 \tab \tab - maju staticke parametre (napriklad aku funkciu zavolat alebo aky premennu naloadovat, potrebujem to vediet, skor ako s tym zacnem nieco robit)}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 \tab za povsimnutie stoji, ze u instrukcii teda potrebujem iba cislo, kam by sa eventualne skocilo (if, repeat...), samotnu instrukciu a string, potazne cislo (takze staci instrukcia, cislo, string ako struktura)}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 \tab }
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 Instrukcie}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs20\lang3081\loch\f5\fs20\lang3081 
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 \tab Vsetky operacie s cislami + vsetky funkcie -> nepotrebuju nic pridavne, vsetko si beru zo ciselneho stacku}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 \tab loadovanie premennych a ich ulozenie -> string, potrebuju vediet, co loaduju}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 \tab zistovanie vlastnosti objektu ->  podobne : (see(3).IsMoving())}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 \tab Dalsie zvlastne instrukcie:}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 \tab \tab -label}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 \tab \tab -jump ( pre if, else, while, repeat, for -> potrebuju vediet, kam skocit)}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 \tab \tab -clean_local_variable - po kazdom skonceni sa vymaze premenna, ktora bola prvy krat pouzite v tomto bloku, aby sa zamedzilo zbytocnemu hlteniu pamate bota, ktory ju ma obmedzenu.}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs20\lang3081\loch\f5\fs20\lang3081 
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 Uchovavanie premenych:}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 \tab Strom, vytvori sa pri inite a nemaze sa, pokial nepresiahne urcitu velkost, ktora sa pocita externe ( teda bot si pamata uz moc premennych a akoby nema 'miesto' pre dlasiu, hoc by aj fyzicky mohlo byt) \u8211\'3f bot si proste nieco zmaze a tym strati informacie, 
co bolo v tej premennej,co sa zmazala, popripade strati funkciu a nebude ju uz vykonavat (ta sa neda loadnut podobne ako premenna, resp. nepozname 'neinicializovanu funkciu' )}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 \tab Pri pristupe na tieto premenne bud bot skonci alebo (lepsie) sa mu dostane neinicializovana hodnota. }
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 \tab U kazdeho uzlu je napisane: - ci je premenna aktivna ( podal toho sa pozna, aky typ to je ( point, object alebo integer, potazne este neinicializovana) -> globalna premenna bude aktivna stale,}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 \tab \tab \tab \tab \tab - velkost zanorenia, v ktorom bola tato premenna vytvorena (dolezite pre mazanie lokalnych premennych), pred kazdym blokom bude specialna intrukcia, ktora nestoji vlastne nic, a to zvys_zanorenie a zniz_zanorenie;}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 \tab \tab \tab \tab \tab - samotne hodnoty premennej (odtial sa bude loadovat)}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 \tab Rozoznavanie vnorenej premennej -> v pripade, ze rekurzivne volam istu funkciu, v strome sa mi prida jej strom premenych pod funkciu, v ktorej som prave zanorena \u8211\'3f pri vystupe sa  tento strom nemusi mazat, iba oznacit za 'neplatny', spoplatni sa zase v ok
amihu, ked danu funkciu v rovnakom kontexte zavolame.}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 V pripade skoncenia bloku sa vsetky premenne tu deklarovane musia znehodnotit -> to sa spravit tak, ze ako poslednu instrukciu po bloku este pridam instrukciu 'clear_local', ktora od korena danej funkcie prejde vsetky premenne, ktore sa vytvorili s indexom
 'vnorenia', aky je maximalne nastaveny (pri kazdom zaciatku bloku sa zvysuje, po konci znizuje, udrzuje sa ako globalna premenna)}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs20\lang3081\loch\f5\fs20\lang3081 
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 Strom sa bude dotvarat aj pocas behu bota -> pri volani nejakej uzivtalom definovanej funkcie sa do stromu prida (ak tam este nie je) prefix aktualnej funkcie, v ktorej sme (okrem main) , + '.', a deep_copy stromceka funkcie-> presne kopia toho stromu. Pre
menne vo funkcii su oznacene teda v hlavnom strome ako 'nazov_funkcie.meno_premennej'. Predide sa tak zistovaniu, ci je premenna lokalna, potazne pri rekurzivnom volani tej istej funkcie nie je problem s menom premennej.}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs20\lang3081\loch\f5\fs20\lang3081 
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 Ako sa hlada premenna, ktoru ma loadovat -> bude je to lokalna vo funkcii alebo globalna uplne -> bud zacnem uplne od korena a idem po strome alebo zacnem vnutri funkcie. Ak sa hlada funkcia, staci mi prehladat iba koren, jelikoz vnorene funkcie nepodoporu
jem (ani nevidim velky zmysel)}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs20\lang3081\loch\f5\fs20\lang3081 
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 Samotne implementacia priebehu boja:}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 fronta poziadavkov na plochu, co sa deje -> pouzitie ale viacero threadov, aby pri pryslani ineho bota sa mohli premyslat / konat aj ostatni.}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs20\lang3081\loch\f5\fs20\lang3081 
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 Rekurzia:}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 pocet rekurzii radsej bude odmedzeny tym sposobom, ze bude obmedzena velkost stacku instrukcii -> povedzme, ze 1000 instrukcii v hlavnom kode, tym sa omedzi rekurzia a nebude sa vsetko pchat do globanych premennych, jelikoz te by zabrali }
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs20\lang3081\loch\f5\fs20\lang3081 
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 Samotne prevadzanie instrukcii:}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 stack bude vzdy naalokovany na maximalnu moznu velkost. najskor sa do stacku prekopiruje kompletne cela funkcia 'main' a zacnu sa vykonavat instrukcie.}
\par \pard\plain \ltrpar\s8\ql\rtlch\af5\afs20\lang255\ltrch\dbch\af5\langfe3081\hich\f5\fs24\lang3081\loch\f5\fs24\lang3081 {\rtlch \ltrch\loch\f5\fs24\lang3081\i0\b0 V pripade, ze sa bude odovzdavat aj parameter referenciou, bude na konci kazdej uzivatelom definovanej funkcie alebo procedury dalsia instrukcia, ktora hovori, zev pripade,ze boli parametre var-ovane, nech sa zisti, ako boli volane potom tam daj hodnotu.}
\par }