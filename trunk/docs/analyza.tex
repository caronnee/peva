\section{Jazyk}
\subsection{Analyza funkcie a preddefinovanou hodnotou parametru}
zavedeniu funkcie s preddefinovanou hodnotou parametre má jediný, pomerne malý dôvod. V okamihu, keď sa robot a nejaký iný objekt sa naplánujú na rovnaký čas, ten, ktorý sa naplánoval skôr, skôr tiež príde na radu (jedna z podmienok fair-play). Ak však robot zavolá funkciu, ktorá má preddefinovaný parameter, po zavolaní sa ocitne pred robotom, aj keby mali rovnaké programy a začínali rovnaký čas. To môže tomuto robotovi priniesť isté výhody, pretože sa dostane na radu skôr s predstihom minimálne 3 tickov (1 za assign a 2 za loadovanie premenných). Za ten čas sa podla tabuľky dá spraviť inštrukcia STEP a teda sa napríklad efektívne vyhnúť strele. V skratke, čím skôr sa robot dostane na radu, tým je to pre neho výhodnejsie, lebo môže skôr reagovať na udalosť a predísť následkom a tým viac sa na radu vlastne dostane. Príklad: Strela S je naplánovaná na čas {\it s1}, robot R je po rozmýšľaní 10 tickov pred strelou strelou (predpokladáme, že zavolal funkciu s preddefinovaným parametrom a inak by bol naplánovaný maximálne 9 tickov pred S) Za ten čas sa môže 2x pohnúť, poťažne použiť inštrukciu see, zistit polohu strely a vystreliť jej smerom.
\subsection{Životnosť premenných vnútri bloku - scoping}
\indent Podobne ako v programovacích jazykoch C, Java , Delphi a pod., je použité statické zapúzdrovanie premennych. To znamená, že prístup k hodnotám, na ktorá odkazuj dané meno premennej, je len v bloku, kde bola funkcia deklarovaná a v žiadnom ďalšom podbloku premenná s rovnakým menom nesmie byť deklarovaná. Napríklad vo funkcií 
$for (integer i = 0; i<10; i++)
{
	code;
}$
premennú i už nie je možné použiť mimo cyklu a naopak táto premenná nebola predtým deklarovaná v žiadnom v nadradených cykloch. Vo väčšine programovacích jazykoch je zapuzdrovanie ideálnou metódou na zprehľadnenie kódu tým, že pod premennou s rovnakým menom sa skrýva premenná rôzneho typu v rámci bloku. Typickým príkladom napríklad v jazyku C je \\$for (int\ i =0; i< 10; i++)$ \\ $ {//blabla}$ \\V našom prípade je ale situácia trochu zložitejšia. Ako bolo povedané v úvode, každá inštrukcia robota niečo stojí, rovnako inizializovanie novej premennej a jej deinicializovanie tiež, takže z tohoto hľadiska na tom robot iba tratí,čo je temer vždy nežiaduce. Dôvod pre zavedenie zapúzdrovania aj v tomto prípade je, ze v okamihu, keď robot použije takúto funkciu, má to dva efekty: \\
		\begin{itemize}
		\item v pamati bude mať pochopitelne o jednu premennú viac. Keďže pamať robota nie je neobmedzená a je uživateľom definovaná na úkor iných vlastnosti(napríklad odolnosti voči zbraniam), pri kóde typu:
for (integer i = 0; i< 10; i++)
{
	code
}
fce1();
fce2();
fce3();
..
môže pri nepodoporovanom zapúzdrovaní robotovi dojsť pamať napriek tomu, ze ďalšie použitie premennej i sa už ďalej nevyskytuje. Pri nepodporovanom zapúzdrenía súčasne výskyte premennej po danom cykle by bolo stejne akoby bola premenná definovaná v nadradenom cykle, to znamená, že až na virtuálne uvoľnenie premennej z pamäti robota by penalizácia bola úplne rovnaká.
\end{itemize}
Z tohoto dôvodu je teda zapúzdrovanie povolené. \\

Problém môže nastať v okamihu, keď sú povolené rovkako rekurzívne funkcie. V okamihu zavolania takejto funkcie, 
