\documentclass[12pt,notitlepage]{report}

\usepackage[utf8]{inputenc}
\usepackage{slovak}
\usepackage{indentfirst}
\usepackage{longtable}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% custom settings and definitions - begining

\def\CS{$\cal C\kern-.1667em\lower.5ex\hbox{$\cal S$}\kern-.075em $}

%% custom settings and definitions - end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagestyle{plain}
\frenchspacing 
\usepackage[utf8]{inputenc}
\usepackage{a4wide}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{psfrag}
\usepackage{vmargin}
\usepackage{color}
%\usepackage[left=4cm]{geometry} % nastavení dané velikosti okrajů
\begin{document}
\begin{titlepage}
\begin{center}
\vspace{15mm}


\large
Univerzita Karlova v Praze\\
Matematicko-fyzikální fakulta\\


\vspace{5mm}


{\Large\bf BAKALÁRSKA PRÁCA}


\vspace{10mm}


\includegraphics[scale=0.3]{logo.eps} 


\vspace{15mm}


{\Large Eva Pešková}\\ % doplHte vaae jméno
\vspace{5mm}
{\Large\bf Codewars, vojna robotov }\\ % doplHte název práce
\vspace{5mm}
Katedra distribuovaných a spolehlivých systémů
\vspace{15mm}


\large
\noindent Vedúci bakalárskej práce: RNDr. Tomáš Poch
\vspace{1mm} 


\noindent Studijní program: Všeobecná informatika % doplHte odpovídající údaje


\vspace{20mm}


2010
\end{center}
\end{titlepage}


\normalsize % nastavení normální velikosti fontu
\setcounter{page}{2} % nastavení íslování stránek


\vspace{10mm} 


\noindent Ďakujem svojmu vedúcemu RNDr.Pochovi za vedenie práce, cenné rady a maximálnu ústretovosť a svojej rodine za morálnu podporu. 


\vspace{\fill} 
\noindent Prehlasujem, že jsem svoju bakalárskou prácu napísala samostatne a výhradne s použitím citovaných prameHov. Súhlasím so zapožičovaním práce a jej zverejňovaním.


\bigskip
\noindent V Praze dne 6.8.2010 \hspace{\fill}Eva Pešková

%%%   Výtisk pak na tomto míste nezapomeHte PODEPSAT!
%%%                


\tableofcontents


\newpage % pYechod na novou stránku


%%% Následuje strana s abstrakty. DoplHte vlastní údaje.
\noindent
Název práce: Codewars, vojna robotov\\
Autor: Eva Pešková\\
Katedra (ústav): Katedra distribuovaných a spolehlivých systémo\\
Vedoucí bakaláYské práce: RNDr. Tomáš Poch\\
e-mail vedoucího: tomas.poch@d3s.mff.cuni.cz \\


\noindent Abstrakt: V predloenej práci navrhujeme a implementujeme prostredie pre testovanie algoritmov. Tieto algoritmy majú odrá~ae stratégiu pou~ite>nú  v rozliných bojových hrách proti umelej inteligencii. Práca analyzuje mo~né podmienky pre víeazstvo a vplyvy astí kódu na vykonávanie algoritmu. Kladie sa dôraz na jednoduchose jazyka popisujúceho algoritmus, rozaírite>nose a 
\noindent Klíová slova: robot, vojna, prostredie


\vspace{10mm}


\noindent
Title: Codewars, battle of robots\\
Author: Eva Peaková\\
Department: Katedra distribuovaných a spolehlivých systémo\\
Supervisor: RNDr. Tomáa Poch\\
Supervisor's e-mail address: tomas.poch@d3s.mff.cuni.cz \\


\noindent Abstract: In the present work we study ... Uvede se anglický abstrakt v rozsahu 80 a~ 200 slov. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Ut sit amet sem. Mauris nec turpis ac sem mollis pretium. Suspendisse neque massa, suscipit id, dictum in, porta at, quam. Nunc suscipit, pede vel elementum pretium, nisl urna sodales velit, sit amet auctor elit quam id tellus. Nullam sollicitudin. Donec hendrerit. Aliquam ac nibh. Vivamus mi. Sed felis. Proin pretium elit in neque. Pellentesque at turpis. Maecenas convallis. Vestibulum id lectus. Fusce dictum augue ut nibh. Etiam non urna nec mi mattis volutpat. Curabitur in tortor at magna nonummy gravida. Mauris turpis quam, volutpat quis, porttitor ut, condimentum sit amet, felis. \\


\noindent Keywords: robot, war, enviroment


\newpage



\input uvod.tex
\input anal1.tex
\input anal2.tex
\input anal3.tex
\input impl.tex
\input zaver.tex
%\chapter{Uvod}
%<v uvode nieco chyba>\\
%Codewar (war of codes) sa pouziva ako oznacenie pre sutaze, ktorych cielom je vytvorit algoritmy pomocou programovacieho jazyka a nasledne vyhodnotit podla nejakeho vzorca najlepsi(najrychlejsie napisane, pouziva najemenej premennych...). Tato bakalarska praca sa zaobera uzkou podmnozinou, a to subojmi robotov. Princip (napisat algoritmus a nasledne vyhodnotit) zostava rovnaky, to, na co sa tieto algoritmy pouziju, je vnutorna logika robota ( chodi rovne, otoci sa, zdvihne ruku...).
%\section{Motivacia}
%%preco zrovna tato praca, ake to bude fajn, ze nieco taketo bude
%Vysledkom bakalarskej prace by mal byt taky program, v ktorom je vyzvou naprogramovat robota a vpustit ho do prostredia, kde sa vyhodnocuje jeho algoritmus. Vysledny produkt ma tak prvky strategickej bojovej hry. Kedze ide o suboj, je logicke, aby sledovanie uspesnosti pozostavalo zo sledovania robota, ktory vykonava dany program. K tejto tematike existuje mnozstvo pristupov, konkretne napriklad implementovane koncepty v hrach:
%\begin{itemize}
%\item (pod kodovym oznacenim "povodne codewars";))ARES , co je hra, ktora sa odohrava na mieste simulujucom pamat pocitaca, ulohou hraca je naprogramovat robota v tomto prostredi. Hrac s naprogramovanym robotom prehra v okamziku, ked vstupi na policko robota, kde nie je uz ziadna instrukcia.
%\item pogamut je pre zmenu vysoko komplexna hra, kde sa roboti daju programovat v Jave, prostredie je trojrozmerne, roboti maju na vyber spustu zdrani, siroku skalu pohybov atd.
%\end{itemize}
%Tieto hry uspokojujuco splnaju problematiku boja algoritmov. Uzivatel ma moznost naprogramovat postavu a  ma moznost ju vypustit do sveta proti inym postavam s inym programom(je nutne saa opakovat?). Lisia sa vsak sposobom, akym dosahuju ciel, definovanie vitazneho algoritmus, ako docielit vitazstvo, pozuzitim skodenia ostatnym robotom a podobne. Obrazok na (TODO) naznacuje zmeny, ktore boli oproti predstavenym hram spravene:
%\begin{itemize}
%\item priestor, kde sa dohravaju. Kym v ARESe ide o v postate 1d priestor ( vedna velka pamat ), boj v pogamute sa odohrava v 3d priestore. Nethack naopak pouziva 2d priestor, ale dikretny, rozdeleny na policka a casti. Variatne 3D priestoru pre codewars bola zavrhnuta pre prilisnu narocnost implemetacie, varianta s 1d zas neposkutuje prilis velky priestor pre visualizaciu a vymyslanie pohybu, preto bola zvoleny 2d priestor
%\item moznost pohybu po svete. Kym v pogamute/Unreal je pobyb vzhladom na svet velmi romanity ( skakanie do vysky, strilanie zboku, pozeranie hore/dole), v Arese sa o nejakom pohybe neda vlastne ani hovrit, pretoze vsetky akcie, ktore vykovana program. robot, je iba vykonavanie programu, co ale nesuvisi s pohybom, ale priamo so zaplnanim pamate, co je cast oddelena od pohybu
%\item najlepsi algoritmus sa lisi rovnako v zavislosti na uvazovanej hre. V ARESe je jasne, kedy hra skonci, ak hrac narazi na miesto v pamati obsadene uz niekym inym - niekto intrukciu, co tam bola, uz vyhmatol. V Pogamute je situacia o poznanie horsia. Pri programovani bota sleduje clovek, co ho chce vypustit, dva ciele-> bud naprogramovat takeho bota, ktoreho zdolat bude vyzva, alebo naopak takeho bota, o ktorom sa vseobecne vie, ze bude porazitelny, ale nie je trivialne ho obist. Codewars si za svoju hlavnu prioritu kladie programovanie boja, ktory splni kriterium, to znamena, ze kombinuje obe variantu Pogamuta(vitazny program ako najdrsnejsi bot, vitazny program ako macho-bot) a sucasne variantu a Aresa(vitazny program ako ten, co najdhsie vydrzi)
%\item Pogamut naviac od Aresa implementuje omnoho viac sposobov, ako ublizit robotovi, od roznych zbrani po odrazenie guliek. Jedonym sposobom, ako je mozne v ARESe ublizit protivnika, ne zobrat mu tu cast pamati, o ktorej je padny dovod predpokladat, ze ju bude v dohladnej dobre potrebovat. Codewars sa v tomto pripade priklana k moznosti ublizit protivnikovi aj nablizko aj zdaleka, a to tak, ze je ucinok okamzity, pretoze je to lepsie pre visualizaciu a znacne to urychli vyhodnotie.
%\item Ani jeden z tychto programov ale nema moznost specifikovat, ake budu jednotlive vlastnosti botov, ci ich skoli jedna rana v pripade pogamuta, alebo, v pripade aresa, moznost ejakeho obmedzeneho "respawnu". V bojovych hrach sa zdalo v case prace vhodne implementovat moznost pre uzivatela, aby si pred samotnym vypustenim do boja mohol tieto vlastnbosti upravit a tym zmenit priebeh bitky
%\item Dalzim dolezitym medznikom je aj sposob, v akom poradi su akcie hracov interpretovane. V arese je to jednoduche, hra prebieha po kolach, ked kazde jedno kolo znamena vykonanie aktualnej instrukcie, teda je to spravodlive pre vsetkych hracov. V pogamute sa tota spravodlivost riesi zdanlovou paralelizaciou. Kedze pri bojoch je spravodlivost vitana, bolo uznane za vhodne skombinovat tieto techniky tak, ze instrukcie sa vykonavaju nezavisle na procesorovom case, teda po kolach, ako je tomu a ARESE, ale sucasne je simulovana cena. Nastavenim ceny na jednicky sa ptoom tento koncept rovna ARESu, inym nastavenim simuluje program procesorove kvantum pridene na vykonavanie instrukcie/vlakna.
%\end{itemize}
%\section{ciele praca(iluzie)}
%\begin{itemize}
%\item vytvorenie sveta v dvojrozmernom priestore
%\item interakcia s postavami, ktore maju moznost si nejak ublizit
%\item moznost zmenit konceot sveta ( penalizacie )
%\item moznost zmenit postavu ( vlastnosti )
%\item moznost napisat algoritmus
%\item moznost testovat vitaznost algoritmu visualne, to znamena pustit robota ovladaneho tymto programom do pripraveneho prostredia
%\item moznost definovat, kedy je algoritmus vitazny
%\item moznosti roznych pristupov k ublizovaniu ( strielanie, vrhanie bomb )
%\item moznost zmeny sveta postavou
%\item moznost ovplyvnenie postavy inou postavou ( dominance! )
%\item postava bude mat moznost hybat sa
%\item postava bude mat moznost zistit, ktore objekty su v jej okoli
%\item postava bude moznost ublizit robotovi z dialky aj z blizka
%\item svet bude mozne pripravit/ vygenerovat na pozidanie hracom
%\end{itemize}
%Negativne vymedzenia, ktore vyznamym sposobom rozsiruju program generovany bakalrskou pracou a preto su uvazovane, ale pre prilisnu pracu s nimi nie je vo vyslednom programe ratane ...( co by bolo fajn ale ani omylom neplanujem, preto)
%\begin{itemize}
%\item nemoznost skakania 
%\item nemoznost zasielania sprav
%\item moznost vymienania zbrani
%\item rozne druhy zbrani
%\end{itemize}
%\chapter{Analyza}
%\section{svet}
%\subsection{Predstava sveta}
%\begin{itemize}
%\item Svet ako obal objektov, ktore v nom ziju. 
%\item Objekty, ktore by sa vzhladom na motivaciu mali vo svete bezpodmienecne vyskytovat-> ako bojova scena -> strelu, steny, ktore strely zastavuju( spokytuju krytie), postavy. motivacia k nim: steny -> zastavenie pohybu\& blokovanie striel. 
%\item V ramci stien, ktore blokuju strelu -> pohybujuce sa steny na poskytnutie ineho krytu ( styl sokoban ), rozbitne steny, nepodporena kombinacia ( implementacna narocnost )
%\item Moznost "prepasti" ako policka, kde by robot nmal vstupovat -> simulacia miny, vyssia narocnost na strategicke rozhodovanie.
%\item moznost definovania miesta, kde ma robot dorazit -> simulacia najdenia pokladu
%\end{itemize}
%\subsection{dynamika sveta}
%\begin{itemize}
%\item akcie, ktore mozu jednotlive objekty vykonavat, dovody, preco su prave tieto akcie potrebne ( strely -> litak, ok, ale odraz od steny, nicenie steny, kolidovanie a jeho vysledky )
%\item pohyb, pixelove rozlisenie vs rozlisenie na policka,  dovody vybrania pixelovej orientacie -> plynula animacia, rozhodnutie, do ktorej mriezky xco kde patri pri pohybe
%\item riesenie kolizi vzhladom na riesenie ukladania pozic, navrh algoritmu n dovody, porovnanie vykonnosti ( quadtree vs mriezkova metoda )
%\end{itemize}
%Sucastou pracu by malo byt aj generovanie map alebo iny pristup pre vytvaranie vlastnych map
%\subsection{Vytvaranie map}
%\begin{itemize}
%\item pristup ako k textovemu suboru, +/-
%\item pristup ako sucast aplikacie
%\item Algoritmus pre generovanie map, vysledkya a porovnanie pre skusane algoritmy
%\end{itemize}
%\section{Programovatelnost postavy}
%program ako testovanie vitazneho algoritmu ( motivacia ), za urcenych podmienok na istych mapach
%\subsection{Rozsirenie sveta vzhladom na programovatelnost}
%\begin{itemize}
%\item Pre splnenie motivacie -> nutnost  implementovat penalizacie-> zvysenie obtiaznosti naprogramovat jazyk, zvolit strategiu, ktora penalizaciu co najviac vykompenzuje. 
%\item priebeh penalizacie  - dva sposoby planovania cakania, popis
%\item mapa obohnana kontrolnymi stenami, aby sa nedostal ziadny objekt mimo mapy -> jeden z moznych pristupov
%\item nutnost definovat si podmienky. Vzhladom na objekty a miesta v mape je mozne definovat -> zabitie urcitej postavy, dostanie sa na iste miesto
%\item z toho vyplyvajuce -> kazda postava by mala mat unikatne meno. Je mozne mat stejne -> simulacia skupina zlodejov prosti policajtom, interpretacia -> skupina zlodejov po zabiti kamarada hromadne zdrhne, skupina policajtov po zisteni, ze nedokazali zabranit kradezi poda hromadnu vypoved
%\end{itemize}
%\subsection{Programovaci jazyk - moznosti}
%popis moznosti, ako jazyk intepretovat, kde sa to vyskytlo, +/-
%\begin{itemize}
%\item graficke jazyky, pomocou diagramov -> pomenre zlozita implenetacia, nutny interpret
%\item LUA - spatna implenentacia penalizacii
%\item vlastna definicia jazyka - plna kontrola pre pripadnu rozsiritelnost a penalizacie, nutny interpret
%\end{itemize}
%\subsection{Vytvorenie noveho jazyka} (norma jazyka, co sa kde smie pouzivat)
%\begin{itemize}
%\item minimalna sila jazyka, co vsetko by mal minimalne zvladata(rekurzie, preco, priklad, aritmeticke, relacne opracie, continue, break, prirovnanie k inemu jazyku, nie dedicnost, nie struktury, okrem pozicei miesta) programom by mali byt zistitelne nasledujuce veci o svete
%\begin{itemize}
%\item miesto, sa postava nachadza. Zistitelna pozicia by mala byt aj u ostatnych objektov -> funkcia localize()
%\item -> poziadavka na program => definovanie struktury na urcenie pozicie -> z prezentacie sveta vyplyva -> pixelove suradnize stredu
%\item z toho vyplyvajuca premenna objekte
%\item z toho vyplyvajuce, ze musi v jazyku ecistovat premenna typu Object
%\item nove funkcie see() -> naplni pole objektov vidtelnymi objektami
%\item poziadavna na jazyk -> definovanie poli
%\item poziadavka na svet -> definovat, co je to viditelny objekt, ktory je v dosahu viditelnosti a sucasne existuje cast nezakryta opstatnymi objektami -> obr
%\item  poziadavka na moznosti pohybu, otocenia, cakania,..
%\end{itemize}
%\item syntax jazyka
%case - sensitive, dovod pre rychlejsiu implementaciu -> inak staci kazde slovo prehodit do malych/velkych pismen
%\begin{itemize}
%\item kodove slova typu this, null, for, while, repeat, real, integer, function..., tabulka vysvetleni
%\end{itemize}
%\item priklady pouzitia (napisane algoritmy)
%\end{itemize}
%\section {Interpretacia jazyka}
%\subsection{mozne pristupy}
%\begin{itemize}
%\item cisty interpret ( mysleno nieco ako AWK, ciste text ), co sa mysli pod zistym interpretom ( ziadne dalsie upravy, ovladanie bota by sa priamo generovalo z textoveho suboru/bufferu). Spomenut rozdiel medzi skutocnymi interpretmi a intepretom v ramci programu ( u normalneho inteprpretru vyhoda s ppamovanim premennych, v ramci programu je to o zvoleni spravnej struktury ). Vyhody/nevyhody (+/-) vzhladom na vestko, aj co nakoniec nebolo implementovane:
%\begin{itemize}
%\item pomale, parsovanie kodovych slov za chodu(-)
%\item lahko implementovatelne ( spusta switchov )
%\item nie je nutne pisat ziadnu dalsiu pomocku, precuje sa iba s textom (+)
%\item mala abstrakcia
%\item referencia na najaky skutocny interpret
%\item nevyhody vzhladom na silu jazyka ( implementovanie penalizacii ) (-)
%\item nevyhody vzhladom na silu jazyka ( detekovanie premennych ) (-)
%\end{itemize}
%\item vlastny prekladac, ale do standartneho medzikodu alebo do strojoveho kodu (x86)(net MSIL, Java BYTECODE), preklad do medzikodu. Rozdiel medzi strojovy kodom a byttekodom/MSIL, priklad, ako to spracuvava Java. Ako by to vyzeralo -> spusti sa program, napise text, vygeneruje byte/strojovy kod, komunikuje medzi sebou dva programy.  Vyhody/nevyhody (+/-)
%\begin{itemize}
%\item portabilita, detaily, preco je ju nutne zmienovat 
%\item v bytekode nutnost implemenetovat sucasne penalizaciu -> nutne prekompilovat vzdy, ked sa zmeni penalizacia (-) 
%\item vyssie mnozstvo prenasanych dat ( samotny jazyk vie o stave postavy, cely stav je prenasany do mapy, kde sa vykresli ) Obrazok komunikacie
%\item (MSIL/Java bytecode) potreba nainstalovaneho prostredia (-)
%\end{itemize}
%\item vlastny prekladac do vlastneho medzikodu ( medzikod spomenuty predtym ), priblizenie prace flex + bison, +/-
%\begin{itemize}
%\item prenositelnost (+)
%\item kontrola nad kodom na softwarovej urovni (mozne zmena za behu -> vyhoda oproti strojovemu kodu), vyhodne pre rozsirenia (+)
%\end{itemize}
%\item preklad do ineho, vyssie pouzitelneho jazyka, predstava prace -> mame textak, ktory je tvoreny robotstinou. mame sustavu knzinic, ktore soracuvaju kusy robotstiny (map(postava, noze s apohni doprava) = ObjectTurnRight), "fail to see difference to bison -> uz teraz tam je vlastna klasa!"
%\end{itemize}
%\subsection{struktura jazyka vzhladom na interpret}
%pouzil sa bison + flex, predstava vyslednej cast interprtru -> rozpad robotstinu na nejake kusy
%\subsubsection{specifikacia instrukcii}
%Uvahy o tom, ake velke kusku instrukcii tam maju byt:
%\begin{itemize}
%\item preklad zvlastnych instrukcii zavislych na svete ( see(), turn() ) -> jedna instrukcia, preco, ako by sa to dalo este zobecnit a preco to nie je treba ( zobecnenie na loadState, extractAbleToMove...,dovod -> zbytocna komplikacia neprispivajuca k pochopeniu jednotlivych istrukcii ), stav robota ukryty v specialnj triede, mimo pamate -> oddelenie, abstraktnych urovni
%\item preklad syntaxe normalne videnej v jazykoch -> deklarovanie premennej, aritmeticke operacie..., porovnanie instrukcii, ako ich vygeneruje napr. LUA a ako ich vygeneruje moj kod, v com sa lisia (obzvlast deklarovanie a odalokovavanie premennych, instrukcie skoku ...n)
%\item preklad zlozenych struktur (pole, location..))
%\end{itemize}
%\subsubsection{preklad z robotstiny}
%\begin{itemize}
%\item premenne akoo tie casti, co sa musia niekma ukladat, aby sa neskor zistila ich hodnota, datova struktura ukladajuca oznacene premenne
%\item drzanie hodnot premennych ( jeden uzol, ktory drzi vsetky typy, ake moze hodnota nadobudnut ), dovod ( porovnanie inych implementacii -> java)
%\item objekt instrukcie ( povidani o jednej abstraktnej triede a jej odvodeninach), kazda instrukcia ma svoju skuoinu, kde patri (stroInteger, storeReal..-> store), dovod -> rozvnaky sposob ukladania
%\item struktura, ktora drzi vsetky instrukcie
%\item specialne instrukcie vyzadujuce dalsie setrenie ( break, continue, cykly ), vo vysledku sa cykly prejdu este raz a skontroluje sa validida (ziadne NULL, nastavenie breakov a continue, preco sa toneda robit za prekladu )
%\item chybne zadany kod, moznosti, co s tym, ci pustit robotas  neuplnym kodom, ako sa bude chovat, vyhodi segfault...
%\end{itemize}
%vedlajsi ucinok -> zpatna rekonstrukcia robotstiny, ako by to vyzeraloi, vratane premennych
%\subsubsection{Vysledna interpretacia}
%popis vsetkeho, zo zatial mame z co potrebuje spolu komunikovat, lokalne zhrnutie vsetkych casti. Rozveedenie komunikacie jednotlivych casti:
%\begin{itemize}
%\item permanentne sa vykresluje mapa. Sme v nejakom stave sveta (svat = objekty a ich pozicia), zobrazenie znamena zistit, ci sa objekt ma prekreslit (flag) a nasledne tu cast vykreslit, Problemy SDL s blitovanim ( pomale ). Plus cakanie na uzivatelsky vstup -> jeden nekonecny cyklus.
%\item dynamicnost -> v nekonecnom cykluse volat planovac postavy -> postava zmeni svoj stav
%\item priebeh planovaca, ako je popisany predtym ( pri konstrukcii penalizacii ) -> stav ready/not ready. Ak je v stave ready, vykona instrukciu, najde penalizacne body (popisane neskor). spracuje ich podla svojho sposobu
%òm struktura pre penalizzcie ->  globalna, dovod (implementovatelnost+motivacia hry -> vyuzivanie kiektorych instrukcii menej, fair play), jedno pole, pristup = id skupiny instrukcii
%\item vykoanie jednej instrukcie = volanie jednej virtualnej metody
%\item praca s premennymi, ukladanie premennych na hodnotovy zasobnik a neskorsia praca s nimi,
%\item instruckia beginblock, createblock, endblock, vytvaranie premennych, vytvorenie miesta v pamati, dealokacia po opustenie bloku, preco dealokacia vsetkeho
%\end{itemize}
%\chapter{Implementacia}
%Technicke detaily -> Implementacia programu, SDL a cakanie na vstup uzivatela, rozdelenie na komponenty
%\section{svet}
%\begin{itemize}
%\item cyklus vykreslovania ( nekonecne volanie )
%\item mriezkova metoda na ukladanie objetov
%\item prekreslovanie iba casti obrazkov, sposob, akym  sa obrazaok prekresli ( nastreli sa tam pozadie o velkosti min/max ), ciastocny update, vysledne zruchlenie, predenie vsetkcyh mriezok
%\item riesenie kolizii vzhladom na pozuuity algoritmus detekovania kolizii
%\item riesenie situacie, ked postava vujde mimo hracieho
%\item vykreslovanie vyrezy mapy ( mapa vacsia ako maximum obrazovky)
%\item vykreslovanie obrazkov pomocou triedy imageWork -> ulozenie vsetkych stavov do jedneho obrazka a posuvanie vyrezov
%\end{itemize}
%\section{preklad a intepretacia}
%architektura prekladaca a interpretra, 
%\nopagebreak
%\chapter{porovnanie}
%\begin{itemize}
%\item podobne veci s prgramovatelnymi robotmi ->povodne Codewars ako bojuvka
%\item spojenie principu bojuvku a prvkov podmienok
%\item niekde inde zavisle instrucie, penalizacia
%\end{itemize}
%\chapter{zaver}
%\section{Zhodnotenie splnitelnosti cielov}
%\section{Mozne rozsirenie do buducnosti}
%\begin{itemize}
%\item posielanie zprav mediz robotmi, co to zlepsi-> implementovanie pocutia
%\item udalosti on event...
%\end{itemize}
\addcontentsline{toc}{chapter}{\bfseries Literatúra}
\addcontentsline{toc}{chapter}{\bfseries Prilohy}
\begin{thebibliography}{99}
\bibitem{sdl} http://libsdl.org
\bibitem{robocode} http://robocode.sourceforge.net/
\bibitem{mlaskal} http://ulita.ms.mff.cuni.cz/pub/predn/pp/
\bibitem{trees}Steffen Heinz and Justin Zobel and Hugh E. Williams,
    \emph{Burst Tries: A Fast, Efficient Data Structure for String Keys},
    ACM Transactions on Information Systems, 2002,
    volume 20, pp. 192--223.
\bibitem{msvl} http://msdn.microsoft.com/en-us/library/bb905470.aspx
\bibitem{java} Tim Lindholm, Frank Yellin :\emph{The JavaTM Virtual Machine Specification, Second Edition}
\bibitem{lua} lua.org
\bibitem{Karel} http://karel.webz.cz/
\bibitem{herbert}http://mpherbert.codeplex.com/
\bibitem{quadtree}   Mark de Berg, Marc van Kreveld, Mark Overmars, and Otfried Schwarzkopf (2000). \emph{ Computational Geometry (2nd revised ed.) }. Springer-Verlag. ISBN 3-540-65620-0.  Chapter 14: Quadtrees: pp. 291–306.
\bibitem{usedPictures} Použitá galéria obrázkov: http://www.bghq.com/fft 
\bibitem{koth} http://sumost.ca/steve/games/ - rozcestník hie zaoberajúci sa algoritmamy prežitia
\bibitem{ares}http://harald.ist.org/ares/ 
\bibitem{crobots} http://www.gamerz.net/c++robots oficiálna stránka hry C++ Robots
\bibitem{flex}Lex \& Yacc John R. Levine, Tony Mason, Doug Brown Paperback - 366 pages 2nd/updated edition (October 1992) O'Reilly \& Associates
ISBN: 1565920007
%\bibitem {codewars} http://thegeekdistrict.com/topic/23-ares-codewar-and-other-programming-games/
\end{thebibliography}
\appendix
\chapter{CD}
Prilohou bakalárskej prace je aj CD so zdrojovymi subormi.
%\section{behove prostredie}
%Pre beh aplikacie je nutne mat nainstalovane SDL verzie 1.2 alebo 1,3, (kniznu QT verzie 4), XML kniznicu libxml2 a kompiler gcc verzia 4
%\section{Instalacia}
%\begin{itemize}
%\item Pre unix -> make
%\item Pre windows -> prilozene solution ( progressing )
%\end{itemize}
\section{struktura CD}
\begin{itemize}
\item image obsahuje obrázky nutné pre vykjreslenie základného menu
\item graphic obsahuje implenet=aciu tried Skina SkinWorker
\item scheduller obsahuje implementáciu plánovača
\item language obsahuje všetky štruktúry potrebné pre vygenerovanie medzikódu
\item objekct obsahuje implementáciu všetkých objektov, ktoré sa môžu vyskytovať v mape.
\end{itemize}
Každá táto časť ďalej obsahuje podadresáre h a cpp s hlavičkovými a zdrojovými súbormi
%%http://blogs.sun.com/yj/entry/yet_another_way_to_hack (jak na bytecode)
\chapter {Gramatika robotštiny}
\begin{verbatim}
#include <iostream>
#include <queue>
#include "../../language/h/lval.h"
#include "../../language/h/robot.h"
#include "../../generatedFiles/h/hflex.h"
#include "../../language/h/parser_functions.h"
#include "../../add-ons/h/macros.h"

#define YYSTYPE Lval 
#define YYLTYPE unsigned
#define YYLLOC_DEFAULT(cur, rhs, n)	do  while(0)
#define YYERROR_VERBOSE 1		

static void yyerror(YYLTYPE *line, Robots* ctx, const char *m);

%}

/* keywords */
%token TOKEN_MAIN "main function"
%token TOKEN_LOCATION "word location"
%token TOKEN_OBJECT "keyword object"
%token TOKEN_VAR_REAL "keyword real"
%token TOKEN_VAR_INT "keyword integer"
%token TOKEN_VOID "keyword void"
%token TOKEN_FUNCTION "keyword function"
%token TOKEN_IF "keyword if"
%token TOKEN_ELSE "keyword else"
%token TOKEN_WHILE "keyword while"
%token TOKEN_DO "keyword do"
%token TOKEN_FOR "keyword for"
%token TOKEN_RETURN "keyword return"
%token TOKEN_BREAK "keyword break"
%token TOKEN_REFERENCE "keyword var"
%token TOKEN_NULL "keyword null"
%token TOKEN_THIS "keyword this"
%token TOKEN_CONTINUE "keyword continue"
%token TOKEN_ROBOT "keyword robot"
%token TOKEN_RND "random function"
%token TOKEN_RET_TARGET "function get_target"
%token<op> TOKEN_OPTION "robot setings"
%token<of> TOKEN_OBJECT_FEATURE "function asking about state"

/* delimiters */
%token TOKEN_SEMICOLON ";"
%token TOKEN_DOT "."
%token TOKEN_COMMA ","
%token TOKEN_LPAR "("
%token TOKEN_RPAR ")"
%token TOKEN_LSBRA "["
%token TOKEN_RSBRA "]"
%token TOKEN_ASSIGN "="
%token TOKEN_BEGIN "{"
%token TOKEN_END "}"

/* literals */
%token<ident> TOKEN_IDENTIFIER " name of variable or function"
%token<number> TOKEN_UINT "integer number"
%token<f_number> TOKEN_REAL "real number"
%token TOKEN_SEEN "seen function"

/* target of game*/
%token TOKEN_VISIT "keyword visit"
%token TOKEN_VISIT_SEQUENCE "keyword visit_seq"
%token TOKEN_KILLED "keyword killed"
%token TOKEN_SKIN "keyword skin"
%token TOKEN_KILL "keyword kill"
%token TOKEN_START "keyword start"

/* group tokens */
%token<operation> TOKEN_OPER_REL "<, >, >=, =<"
%token<operation> TOKEN_OPER_SIGNADD "sign or additive operator"
%token<operation> TOKEN_OPER_MUL "multiplicative operator"
%token<operation> TOKEN_PLUSPLUS "++"
%token<operation> TOKEN_MINUSMINUS "--"
%token<operation> TOKEN_BOOL_AND "&&"
%token<operation> TOKEN_BOOL_OR "|| or !"

%type<ident> function_name "function name"

%type<type> simple_type "simple variable type"
%type<type> complex_type "complex variable type"
%type<type> type "variable type"
%type<type> return_type "return type"

%type<ranges> ranges "range"
%type<ident> function_header "function header"

%type<entries> parameters_empty "zero or more paramaters"
%type<entries> parameters "paramaters"

%type<instructions> names "inicializations"
%type<instructions> names_ "inicialization"
%type<instructions> cycle_for "for cycle"
%type<instructions> local_variables "local variable(s)"
%type<instructions> block_of_instructions "block of instructions"
%type<instructions> global_variables "global variable(s)"
%type<instructions> commands "block of commands"
%type<instructions> command "command"
%type<instructions> matched "if/else block"
%type<instructions> unmatched "if block"
%type<instructions> init "create or assign"
%type<instructions> assign "assign"
%type<instructions> command_var "command or vvariable declaring"
%type<instructions> simple_command "simple command"
%type<instructions> commands_and_empty "nothing or command"

%type<array_access> array_access "[number(,number)*]"

%type<defVal> values "values expression"

%type<output> array "array declaring"
%type<output> variable "variable declaring"
%type<output> variable_left "variable to be assigned to "
%type<output> number "number"
%type<output> declare_functions "declaring function(s)"
%type<output> declare_function_ "declare function"
%type<output> unary_var "unary variable"
%type<output> expression_bool "expression with boolean result"
%type<output> expression "expression"
%type<output> exps "expressions"
%type<output> expression_base "variable or constant"
%type<output> expression_mul "multiplying expression"
%type<output> expression_add "plus expression"
%type<output> expression_bool_base "variable or constant acting as 
					boolean"
%type<output> expression_bool_or "|| expresion"
%type<output> call_fce "calling function"
%type<output> call_parameters "parameters of function being called"
%type<places> places "defining target places"
%type<target> place "defining target place"

%start program

%error-verbose

%pure-parser

%parse-param 

%lex-param 

%locations

%%

program: program robot 
	|robot 
	;
define_bot:TOKEN_ROBOT TOKEN_IDENTIFIER 
	;
robot:  define_bot TOKEN_BEGIN options targets global_variables 
	declare_functions TOKEN_MAIN TOKEN_LPAR TOKEN_RPAR 
	block_of_instructions TOKEN_END
	;
targets: /* default target */  
	|targets TOKEN_VISIT TOKEN_LPAR places TOKEN_RPAR 
	|targets TOKEN_KILL TOKEN_IDENTIFIER
	|targets TOKEN_VISIT_SEQUENCE TOKEN_LPAR places TOKEN_RPAR 
	;
place: TOKEN_UINT 
	|TOKEN_LSBRA TOKEN_UINT TOKEN_COMMA TOKEN_UINT TOKEN_RSBRA
	| TOKEN_START TOKEN_LSBRA TOKEN_IDENTIFIER TOKEN_RSBRA 
	;
places: place
	| places TOKEN_COMMA place
	;
options: /* nothing */
	| options TOKEN_OPTION TOKEN_ASSIGN TOKEN_UINT 
	| options TOKEN_SKIN TOKEN_IDENTIFIER 
	;
global_variables:	/*	no parameters	*/ 
	| global_variables local_variables 
	;
type: simple_type 
	| complex_type 
	; 
local_variables: type names TOKEN_SEMICOLON 
	;
simple_type: TOKEN_VAR_REAL 
	|TOKEN_VAR_INT 
	|TOKEN_LOCATION
	|TOKEN_OBJECT
	;
complex_type: simple_type ranges 
	;

ranges: TOKEN_LSBRA TOKEN_UINT TOKEN_RSBRA 
	|ranges TOKEN_LSBRA TOKEN_UINT TOKEN_RSBRA 
	;

names_:	TOKEN_IDENTIFIER
	|TOKEN_IDENTIFIER TOKEN_ASSIGN expression 
	|TOKEN_IDENTIFIER TOKEN_ASSIGN begin_type values end_type
	;
names: names_ 
	|names names_ 
	;
begin_type: TOKEN_BEGIN 
	;
end_type: TOKEN_END 
	;
values:	expression 
	| values TOKEN_COMMA expression 
	| begin_type values end_type
	| values TOKEN_COMMA begin_type values end_type
	;
declare_functions: /*	no declared functions	*/ 
		|declare_function_ 
		;

function_header:return_type function_name TOKEN_LPAR parameters_empty 
		TOKEN_RPAR 
		;
function_name:	TOKEN_FUNCTION TOKEN_IDENTIFIER
		;
return_type:	TOKEN_VOID 
		|type 
		;

parameters_empty:	
		| parameters 
		;
parameters:	type TOKEN_IDENTIFIER 
		| parameters TOKEN_COMMA type TOKEN_IDENTIFIER 
		| TOKEN_REFERENCE type TOKEN_IDENTIFIER 
		| parameters TOKEN_COMMA TOKEN_REFERENCE type TOKEN_IDENTIFIER 
		;
declare_function_:	function_header block_of_instructions  
		|declare_function_ function_header block_of_instructions 
		;
number:		TOKEN_OPER_SIGNADD TOKEN_REAL 
		|TOKEN_OPER_SIGNADD TOKEN_UINT 
		|TOKEN_REAL 
		|TOKEN_UINT 
		|TOKEN_RND
		;

begin:	TOKEN_BEGIN 
		;

end:	TOKEN_END 
		;

block_of_instructions: begin commands_and_empty end 
		;
commands_and_empty:  /* empty */ 
		| commands 
		;

commands: 	TOKEN_SEMICOLON 
		| matched 
		| commands matched 
		| unmatched 
		| commands unmatched 
		;
cycle_for: TOKEN_FOR 
		;
command:	cycle_for TOKEN_LPAR init expression_bool TOKEN_SEMICOLON 
		simple_command TOKEN_RPAR begin commands end 
		|TOKEN_DO begin commands end TOKEN_WHILE TOKEN_LPAR 
		expression_bool TOKEN_RPAR TOKEN_SEMICOLON 
		|TOKEN_WHILE TOKEN_LPAR expression_bool TOKEN_RPAR 
		begin commands end
		|TOKEN_RETURN expression TOKEN_SEMICOLON
		|TOKEN_RETURN TOKEN_SEMICOLON 
		|TOKEN_BREAK TOKEN_SEMICOLON 
		|TOKEN_CONTINUE TOKEN_SEMICOLON  
		|simple_command TOKEN_SEMICOLON 
		;
command_var: local_variables 
		| command  
		;
simple_command:	assign  
		|unary_var 
		;
assign: variable_left TOKEN_ASSIGN expression 
		;
array: TOKEN_IDENTIFIER array_access 
		|TOKEN_SEEN TOKEN_LSBRA expression TOKEN_RSBRA
		;

call_fce:	TOKEN_IDENTIFIER TOKEN_LPAR call_parameters TOKEN_RPAR 
		|TOKEN_OBJECT_FEATURE TOKEN_LPAR call_parameters TOKEN_RPAR 
		;

call_parameters: expression 
		| /* ziadny parameter */ 
		|call_parameters TOKEN_COMMA expression 
		;
matched:TOKEN_IF TOKEN_LPAR expression_bool TOKEN_RPAR matched 
		TOKEN_ELSE matched 
	| command_var  
	|block_of_instructions 
	;
unmatched:	TOKEN_IF TOKEN_LPAR expression_bool TOKEN_RPAR 
		block_of_instructions 
	|TOKEN_IF TOKEN_LPAR expression_bool TOKEN_RPAR command 
	|TOKEN_IF TOKEN_LPAR expression_bool TOKEN_RPAR matched 
		TOKEN_ELSE unmatched 
	;
init: 	local_variables 
		| assign TOKEN_SEMICOLON 
		;
unary_var: variable 
		|variable TOKEN_PLUSPLUS 
		|variable TOKEN_MINUSMINUS 
		;
variable_left:TOKEN_IDENTIFIER 
		|variable_left TOKEN_DOT TOKEN_IDENTIFIER 
		|array 
		;
variable: 	TOKEN_THIS 
		| TOKEN_NULL
		|call_fce 
		|variable_left 
		;
		
array_access: TOKEN_LSBRA exps TOKEN_RSBRA 
		;
exps: 		expression  
		| exps TOKEN_COMMA expression 
		;
expression_base: unary_var 
		|number
		|TOKEN_LPAR expression_bool TOKEN_RPAR 
		;
expression_mul:expression_base 
		|expression_mul TOKEN_OPER_MUL expression_base 
		;
expression_add: expression_mul 
		|expression_add TOKEN_OPER_SIGNADD expression_mul
		;
expression:	expression_add 
		;
expression_bool_base: expression 
		|expression TOKEN_OPER_REL expression 
		;
expression_bool_or: expression_bool_base 
		| expression_bool_or TOKEN_BOOL_OR expression_bool_base
		;
expression_bool:	expression_bool_or 
		| expression_bool TOKEN_BOOL_AND expression_bool_or 
	;
%%

static void yyerror(unsigned *line, Robots* ctx, const char *message)
{
	ctx->parseError( deconvert<const char *>(message) +" at line " + 
		deconvert<int>(*line) +"\n");
}

\end{verbatim}
\end{document}
