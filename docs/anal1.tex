\chapter{Analýza}
Súčasťou tejto kapitoly je zdôvodnenie jednotlivých rozhodnutí, ktoré sme navrhli. Chceme vytvoriť taký virtuálny svet, v ktorom môzeme pozorovať chovanie robotov, pričom kritériom je zostať naživo a hodnotiacou funkciou je maximálne predlžiť čas života robota.
\section{Virtuálny svet}
Neoddeliteľnou súčasťou hry je virtuálny svet (prostredie), v ktorom sa bude suboj odohrávat. Najskôr vysvetlíme, čo všetko svet obsahuje, ako sa v ňom žije z hľadiska robota i z hľadiska uživateľa (narábanie s objektom v programe) a ako to prispieva k úspešnosti algoritmu. \\ 
% máme dvojrozmerny svet
Uvažovany svet bol vybraný dvojrozmerný, pretože poskytuje dostatok možnosti pre dianie na ploche (smer pohybu, zrozumiteľne vykresľovanie stavu a pod.) a súčasne nie je obtiažne implementovatelný. 
\subsection{Súčasti virtuálneho sveta} %tu by sme mali vediet, ze robotovo telo je to hlavne -> uvedene pod sekciou
Robot žije v prostredí a môže ovplyvňovat (útočiť) ďaľších robotov .na dalsie roboty, teda sám je objektom sveta. Roboti sa smú pohybovať všetkými smermi a tak by sa bez ďaľšich objektov jednalo len o nájdenie robota, ktoýy sa potom môze bránit pohybom (nic iné by vo svete nebolo). Tento prístup je tiež zaujímavý, ale jednotvárny, ráta sa stále s tým istým stavom sveta). Preto uvažujeme aj o ďaľších objektoch dalsie objekty. \\%slo by
Nakoľko háč aktívne nevstupuje do vykonávania algoritmu, je nutne popísať virutálny svet z hľadiska robota, resp. uživateľovou znalosťou objektov, na ktoré môže robot reagovať. 

V ARES-ovi sa robot orientuje podľa dát v pamäti, číta, porovnáva a prepisuje. V POGAMUT-e reaguje robot na vizuálne podnety, ktoré vidí aj pozorovateľ. Hráč ma naprogramovať algoritmus chovania robota a tak je prirodzenejšie použiť podobný princíp ako v POGAMUT-e t.j. zariadiť robotovi možnosť získať informaciu  zo sveta v nejakom obmedzenom okoli. %Obmedzené okolie znamená teda kruhovú výseč. Objekty mimo tejto kruhovej výseče už nebude robot schopný identifikovať. \\ %asi by to chcelo vysvetlit lepsie - je to dostatocne jasne-prej to patri inam KAM? to nespecifikoval
%otazka-> patria tu aj navrhovane algoritmy? Nemam to kam inde dat....
% Navrhnute algoritmy patria do kapitoly Riesenie alebo Implementacia algoritmov
Objekty uvazované vo svete vzhľadom na to, čo môže algoritmus využivať, sú nasledovné: %mozno by to chcelo rozviest, preco robot potrebuje akutne vidiet
\begin{description}
\item[Robot ako objekt]\hfill %vlastnosti robotov, preco by ali byt modifikovane, kontrola, ci to ma byt ako prve
%tu chcem napisat, ze robot sam je objekt, kedze reaguje a ostatnych robotov
Základnou vlastnosťou robota je, že môže ubližovať ostatnýým robotom, musí ich najskôr lokalizovat. Teda roboti sami musia mať vlastnosti objektu sveta (to znamená na ne reagovat) \\ %mozno by to chcelo napisat, co sa mysli pod vlastnostami objektu?
Ako veľmi moc robotovi tieto útoky uškodia, . je vyjadrené celým čislom. Tak sa da  škoda zistiť presne a neobjavia sa problémy s malými čislami alebo zlomkami, ako je to v prípade realnych čisel ( v C je napriklad 0 vyjadrená ako malé nenulové číslo). Čim väčšie čislo, tým väčšia škoda sa deje robotovi. V pripade vzdialeného útoku je tiež dôležitou otázkou, ako ďaleko môže robot zaútočiť. Ak je toto čislo vopred dané, mal by o tom robot vedieť dopredu, aby mohol svoj algoritmus prispôsobit.\\
Útok robotov prebieha na úrovni ich tiel a nie programu (viz hra typu ARES). Ďalšou  otázkou je, koľko takýchto zásahov robot vydrži. Keďze útok je vyjadrený pomocou celých čisel,  je vhodne vyjadriť celočiselne  aj životnosť robotov.\\
Ďaľšou vhodnou vlastnosťou je aktivna obrana proti útokom. Doteraz sa robot mohol brániť len dostatočnm počtom životov. Môze sa tak stať, že pri malom počte životov bude stačiť jedna rana a robot zahynie. Preto ďašia vlastnosť, ktorú uživateľ môže u robota nastavit je, aké množstvo zranenia bude pohltené pred jeho smrťou. Výsledný efekt je ale rovnaký, akoby sa životnosť zvýšila a preto táto vlastnosť nebola použitá.
\newline
%Rozsirit, preco je tento sposob dobry, ako inak sa da ublizovat
%to co neni na koniec? Alebo pomiesane?
\item[Strely] \hfill %musia tam byt strely kvoli vypocitaniu utoku 
\newline % tu sme stale bez stien
%MOMENT, ci to nahodou nie je dynamika?
Roboti by mali vedieť útočit na diaľku. To možno docieliť viacerými spôsobmi:
\begin{itemize}
\item robot zaútoči z diaľky na konkrrétne miesto a tam okamzite vypočíta výsledok útoku. V tom okamihu treba určiť,  kedy smie robot zaútociť týmto spôsobom. Ak môže robot zaútočit na akékoľvek miesto, potom ostatní roboti nielenže nemajú možnost sa útoku vyhnúť, ale strácaju sa aj informácie o tom, odkiaľ útok prišiel (na každé políčko môže byť zaútočené). Stratégie sa zredukuju na dva prístupy - náhodne utočenie zdiaľky na nejaké poííčka a pohyb dovtedy, pokiaľ sa nenájde cieľ a na masívny útok na cieľ.\\ %skontrolovat, ci neexistuje ieco fikanejsie
%nelubi, presnejsie rzviest, preco sa mi to nepaci
\item Minimálne je teda nutné obmedzťt pravidlami, na ktore miesta sa môže útočiť z diaľky. Najviac intuitívne a ľahko zobraziteľné je vymedziť polomer zásahu. Problémom ale stále zostáva nemožnost vyhnút sa útoku na diaľku. Nie je tu možné zaregistrovat útok a adekvátne naň zareagovat, popripade zareagovať na útočnika.\\ % tu by to mozno chcelo este viac rozviest, ze to nie je fajn
\item Ďalšou možnosťou je vytvorenie strely. Strela je objekt, ktorého jedinou činnosťou je pohybovat sa predvídateľne vpred po dobu dopredu  známeho času  (v danom smere výstrelu). Strela však skonči svoju činnosť aj v okamihu, ked spravi útok na blízko - zasiahne objekt.
\end{itemize}
Ak robot útočí tým, že na cieľ vystrelí, strela spraví potom útok nablízko. Tento prístup poskytuje väčšiu voľnost pri útočení, nakoľko stači rozhodnút, v ktorom ísmere  má strela ísť. Ďalej je možné  približne odhadnúť smer, odkiaľ strela prišla.  To je dôležité pri rozhodovani sa, kam ísť, či robota napadnôť priamo (nablizko) alebo odpovedat streľbou. Strely tak boli pridané ako ďaľšie objekty, ktoré zabezpečujô útok na diaľku. Strelivo ale nie je možné dopĺňať, musí byť neobmedzené pre každého robota. Ak robot ale strieľa neobmedzene, potom môže byt hracie pole zahltené strelami, čo výrazne spomalí simuláciu. Preto je počet striel obmedzený. Toto je daľšia vlastnosť robota. Strela sa okamžite po vykonaní útoku vráti k robotovi, ktorý ju vystrelil a ten ju môže použit znova.%<< zujimavy napad
%To, ze steny poskytuju ukryt pre robota tiez znamena, ze steny obmedzuju vyhlad robota.
%Este nejaky sposob planovania utoku na dialku?
\item[Steny] \hfill
Ďaľšim uvažovaným objektom sú objekty, ktoré môže robot využívať na  svoju obranu. Útočiť na robota môžu také objekty len z blízka ( robot z blizka alebo z ďiaľky, čo je to vlastne strela z blizka.  Vo vrituálnom  svete potrebujeme niečo,čo zabraňuje pohybu. Týmito objektami budú steny. Robot ich môže využívat ako strategicky úkryt,  podobne ako vojaci využívaju terénne nezrovnalosti. %TOTO BY SOM DAL PREC CELE? Ja chcem povedat, ze tam robot za to nebude viodet! Ukryt je definovany tak ze ho nezasiahne strela, anie nie, ze nebude visietVzhladom na to, ze steny budu zabranovat pohybu, mali by zabranovat aj robotovi vidiet objekt za stenou. Tato informacia by totiz znevyhodnila robota, ktory sa sikovne skryl. <tot jest blbost, mmnt, spatne argumentujem>
\newline
\item[Prepadliska - nepristupne miesta] \hfill
Strategickým obmedzením sú miesta, na ktoré robot za žiadnych okolnosti nesmie stúpiť. V prípade POGAMUT-a sú to priepasti, jamy, tekutá láva a pod.. V ARES-e zase miesto v pamäti, ktoré obsahuje neplatnú inštrukciu. Existencia prepadlísk umožňuje plánovat stratégiu využívajúcu silný útok z dialľy a vyhýbajúci sa silným útokom zblizka. 
\newline
\item[Štartovné pozície robota]\hfill
\newline
Ak roboti nemajú dopredu dané miesto na  mape, potom sa ich štartovné pozície musia generovat buď náhodne alebo vypočitať tak. aby umiestnenie bolo nejakým spôsobom spravodlivé (nebol zvýhodnený ani jeden robot ). Rozoberme si podrobnejšie jednotlivé ne/výhody virtuálneho sveta bez štartovných pozíicií robotov. Náhodne vygenerované pozície:
%problem zistovania vhodneho miesta
%roboti vedla seba, vyhody, nevyhody? - ani jedno. neskor sa to mohla stat,treba tym ratat
%nevyhoda, ze dopredu neviem
\begin{itemize}
\item[Roboti vygenerovani vedľa seba.] Toto nám ale nevadi, pretože táto situácia môže nastať kedykoľvek počas behu programu a tak na ňu robot musi vedieť zareagovať.
\item[Nájdenie počiatočného miesta] Môže zabrať pomerne veľa času v pripadoch, keď je mapa sveta zložená z veľkeho množstva stien a úzkeho priestoru pre pohyb robotov.
\end{itemize}
Kvôli zabezpečeniu spravodlivosti generovania pozícií robotov bude použitá heuristika. No je otázne čo chápať pod spravodlivosťou. Robot má za úlohu reagovať na každú situáciu, nie je preto nutne uvažovať o špeciálne vypočitaných miestach a tak pojem spravodlivosť stráca svoj význam\\
Problémom zostáva mnoístvo robotov na  mape a dlhé generovanie počiatočných pozícií. Z tohoto dôvodu sa pristúpilo k možnosi vytvorenia štartovacích políčok. To prinaša okrem iného aj možnosť definovať, pre maximalne koľko robotov je mapa ideálna (ráta sa s týmto maximálnym počtom robotov).  Ak ale uživateľ zadá viac robotov, simulácia sa aj potom môze uskutočniť.  Nutné je len uživateľa upozorniť, že prebehol pokus umiestniť robota náhodne a ?????či bol tento pokus úspešný. Ak aj pokus nebol úspešný, nič významne sa nedeje, pretože existuje na mape virtuálneho sveta dostatočné množstvo robotov.
\end{description}
\subsection{Život v prostredí} %mame ublizovanie
Roboti žijô vo svete a snažia sa zničiť ostatných. Keďže ale mapa môže byť rozľahlá a roboti nemusia byť na dosah útoku, roboti sa na výhodnejsie miesto musia dostať. Pohyb môže byt realizovaný ako jednoduchý presun z miesta A na miesto B (teleportácia), alebo ako postupný prechod na druhé miesto. Na druhej strane je ale vhodne definovať najmenšiu vzdialenosť, o ktorú sa zamerne pohne. Hovorme tomu {\bf krok}.\\ % potom by som niekde mohla spomenut, ze to nie je uplne presne, pretoze steny a prepadliska mozu by kdekolvek, takze aj step ( location ).???????
%vseobecne kydy ohladom pohybu, smer, ako daleko atd.
Ideálne sa javí postupné vykonávanie pohybu ( plynulý prechod na ďaľšie miesto), pretože je to prirodzenejšie a takýto pohyb poskytuje priestor pre návrh stratégií. Ak sa robot ocitne pred priepasťou, vie, že robot za ním touto cestou nepride, pretože by spadol.  Podobne, ak je za stenou, robot  pri pokuse ist za ňu narazi a neobjaví sa za ňou?nim, takže je robot istým spôsobom chránený. Otázkou je, ako sa bude tento algoritmus vykonávat, akým spôsobom sa robot dostane do zadaneho miesta. 
\begin{itemize} %ono to vadi aj algoritmu
\item jedným zo spôsobou je, že sa uživateľ nebude trápit tým, ako sa na dané miesto dostane, pretože samotná mapa bude ponúkať  možnosť navigovať robota. Tento koncept zjednodušuje písanie algoritmu uživateľovi??. Následkom tohoto rozhodutia ale nebude mať užívateľ možnosť zistiť, ako dlho bude trvat robotovi  cesta na dane miesto a teda nemôže vedieť ako sa za ten čas zmenil svet. To ale v zasade nie je problem, iba zjednodušuje písanie algoritmov, keď sa raz uživateľ rozhodne, kam chce ísť. Problémom sa môže zdať samotná implementacia. Existujô dva spôsoby, ako pathfinding dosiahnúť:
\begin{itemize}
\item výpočet za behu aplikácie. Potom toto vypočitávanie môže výrazne spomaliť simuláciu, obzvlást ak ide o veľke mapy.
\item Obmedziť mapu na pozície, kam sa robot môže dostať a tieto si uložiť externe. Otázka, akú cestu zvoliť  medzi dvoma bodmi sa potom zjednoduši na postup podľa konkrétnej úsečky. Tento spôsob však vyžaduje netriviálne množsto pamäte najmä pre veľke mapy.%tu by to mozno chcelo referenciu
\end{itemize}

\item pohyb po priamke. Pohyb sa bude bez ohľadu na dostupnosť miesta realizovat po priamke. Preto je nutné zadať podmienku, kedy sa má pohyb prestať vykonávať. Bez tejto podmienky by stačil uživateľovi jeden chybný ťah, aby zblokoval vykonávanie zvyšku algoritmu a tým znemožnil algortimu vyhrať. Robot ale pocas pohybu nebude vykonávať nič iné, a tak bude očakávat, že po nejakom čase sa na tom mieste ocitne. V reči virtuálneho sveta je týmto casom počet krokov. Nakoľko hovoríme o priamke, je jednoduché vypočitať, koľko krokov robota  by bolo treba vykonať. Preto namiesto kontrolovania, či robot skončil na žiadanom mieste, stačí skontrolovať, či robot vykonal dostatočné množstvo krokov. 
\end{itemize}
%patri to este sem? Ale jo, ono to z toho vyplyva SKONTROLOVAT TODO
Čo sa samotného pohybu týka, bude zobrazovaný tak, aby ho oko vnímalo ako plynulý $TODO-nejaka referencia$
% tu chceme este vysvetlit, ze metoda -> jeden objekt jedno polizko ee, viz dungeon 
Pohyb, ktorý môže urobiť robot, je pohyb v ľubovoľnom smere. Smer je určený vektorom $[x,y], x,y \in N $, takže sa ním dá vyjadriť presne smer pohybu. Konkrétny pohyb je potom aproximovaný úsečkou (objekt sa bude pohybovat po úsečke, pričom jeho súradnice bud vypočitané v závislosti na čase). %referencia, tu by mozno chcel obrazok porovnanie bresenheimovho algoritmu a mojho, ukazka pohybov Hmmm znie to mudro
Roboti sa teda môžu pohybovať  všetkými smermi vyjadriteľnými celými čislami. Otázkou je, ako sa samotný pohyb týmto smerom realizuje. Robot vidí istý úsek pred sebou a tak je rozumne mu tiež dovoliť sa otáčať a tým pokryť celé svoje okolie. Pohybujúci sa robot bude môct spraviť nasledujúce veci. Buď sa bude hýbať len smerom, ktorým je otočeny alebo sa bude môcť hýbat kamkoľvek. Tieto dva pristupy maju ale rovnaku priblizne rovnaky efekt. Robot sa v druhom pripade iba nemusi otacat, co je zanedvatelna polozka. Pre jednoduchost bol implementovany sposob chodia len smerov, ktorym je robot otoceny. %<asi by to chcelo nakreslit situaciu CHCE OBR> a toto je blbina
Prvý spôsob si môžeme predstavit ako pohyb u koňa -  ten kde nevidí, nevlezie. Druhý spôsob sa dá prirovnať k pohybu jeleňa - ten v pripade núdze uhýba efektne všetkými smermi..\\
%posuvné steny 
V súvislosti s pohybom je možné uvažovať o rozširení virtuálneho sveta nad rámec popisu v <STATICKY SVET>, a to konkrétne o posuvné steny ako i zvláštny druh stien. Steny zabraňuju pohybu robota a striel, preto prínos posuvných sten je v tom, že robot potom bude môct zmeniť prostredie sveta tak, aby zodpovedal jeho konkrétnemu algoritmu. Vie posunúť stenu tak, aby ho chránila pred streľbou. Napriklad, ak algoritmus počita s tým, že robot bude útočiť na isté miesto, ale cesta na to miestoa prechádza miestom, kde sa neustále pohybuju strely, potom je pre robota vhodné, aby tam mal stenu, za ktorú sa môže schovať. Ak tam žiadna stena nie je, potom existencia posuvných stien dáva nádej na prechod  prejdenie??????? tejto nebezpečnej zóny bez úhony.\\ 
Spôsob s posuvnými stenami ma oproti využívaniu konkrétneho prostredia sveta naviac tú výhodu, že algoritmus musí počitať so zmeneným svetom a tým sa zvyšuje náročnosť hry. Preto svet obsahuje aj posuvné steny. Stále by však virtuálny svet mal možnost mať statické prostredia (neposuvné) steny. %TODO vysvetlit preco
% pod velkostou teda budeme rozumiet...blabla
%riesenie kolizii
\subsection{Kolízie}
V súvislosti s pohybom nastáva tiež otázka, kedy a ako budu objekty navzájom interagovat. Kolízia nastane vtedy, keď sa obrazy objektov pretnú (majú spoločný neprázdny prienik ). To kladie nemalé nároky na štrukturu virtuálneho sveta, ale súčasne  to má tiež vedľajši efekt. Čim väčší obrázok bude symbolizovať objekt, tým väčšia je možnosť kolizie. To môže byť trochu nepríjemné, ale poskytuje to možnosť pre ďalšie rozširenia, keď napr. silnejši robot ( viac života, väčši útok) bude mať povinne väčší aj zodpovedajúci obraz. Kolízia môže nastať prakticky pri akomkoľvek malom pohybe. Na samotné ukladanie objektov do mapy existuje jednoduchý trik, rozdeliť mapu na malé políčka a každé políčko obsadiť práve jedným objektom. To prináša asi väčšie näroky na pamäť (obzvlášť, ak bude veľká mapa a malé poíička), ale zato kolíziu vieme určiť okamžite. Stači zistiť, či v danom políčku, kde leži výsledok pohybu, je objekt rôzny od uvažovaného. Tento spôsob sa dosť často používa v bludiskách, %[mozno napisak jakych? ano ak mozes citovat]
????, kde su objekty rovnako veľke (každée zaberá práve jedno políčko). Nazvime ich {\bf diskrétne bludiská}. Okrem veľkosti políčka má tento pristup ale problém aj s rozhodnutím, kde objekt patrí. Ak sa v mape pohne len o niekolko pixelov, bude patriť stále do jedného políčka, pretože mapa je rozdelená staticky (políčka sa nepohybujú s objektom). Stále však môže kúsok objektu presahovať nad rámec políčka. Teda kolízia nemusí presne zodpovedat tomu, ako je zobrazená. Preto boli ?????????uvazovne nasledujuce algoritmy pre detekciu kolizie, ktore pouzivaju iba veľlkost objektu:
\begin{itemize} %tu pojde popis toho, co priblize robia
\item[Quadtree]
<priblizny popis , vyhody/nevyhody + referecia>
\item[Mriežková metóda]
<priblizny popis , vyhody/nevyhody + referecia>
\end{itemize}
Pre lepšiu implementovateľnost bola zvolená mriežková metóda. Neboli zaznamenané výrazné rozdiely oproti quadtree.\\
Keď máme vyriešenú kolíziu, je treba určiť, ako jednotlive objekty reaguju na kolíziu. Rozhodli sme sa takto:
\begin{description}
\item [Robot vs. strela] Strela ukonči svoj život výbuchom a uštedríi robotovi náležité zranenie. Robotovi sa v tomto okamihu preruši akákoľvek činnosť, ktorú predtým vyvíjal,  (napríklad pohyb ). To zodpovedá tomu, že strela zasiahla cieľ,  ( v tomto ponímaní iba roboti ) a nemá ďalej dôvod pokračovať (žiadne viacnásobné zranenia) % to by mozno chcelo osvetlit preco NACO? No to je rozhodnutie, ale nijak zdôvodnene
Robot si v tomto okamihu nemusí robiť starosti, že strela sa odrazí priamo k nemu. Je však na ďaľšom rozširení, ako sa strela po zásahu bude chovať.
\item [Robot vs. Robot] Roboti nemôžu navzájom interagovať inak ako ubíižením a pri kolízií sa prijavi??? útok na blizko. Tento spôsob zľahčuje písanie algoritmu, nakoľko sa nemusí explicitne deklarovať ôtok nablizko  (útok na diaľku algoritmus musí explicitne vyjadriť, útok na blizko je automatickýy ). Útok na blízko bude prevedený robotom, ktorý spôsobil kolíziu. %TODO rozviest
\item [Robot vs. stena] Pokiaľ robot narazi na stenu, tá ho zastaví. Toto chovanie je prirodzené, pretože stena tohoto typu predstavuje statický virtuálny svet, ktorý sa nemení.%vysvetlenie jak hrom, zmenit!
\item [Robot vs. posuvna stena ] Posuvná stena ma schopnosť meniť svoje miesto. Robot ju má možnosť  posunúť  (musí byť pri stene a pohybovať sa ). Stena by sa mala hýbať len s robotom, keďže cieľom je, aby mu sústavne poskytovala úkryt. Stena sa tak pri kontakte s robotom posunie v smere, v akom ide robot. Ak sa snažia stenu posúvať obaja roboti a smer ich pohybu je vyjadrený dojrozmernym vektorom, potom sa stena pohybuje v smere vektoroveho súčtu týchto dvoch smerov, čo dáva aj fyzikálne prijateľný  zmysel.
\item[Robot vs. prepadlisko] Robot by na prepadlisko nemal stúpať. Ak by sme sa obmedzili iba mna???? nestupnutie??? políčka, stačí  nám stena. Preto robot musí byť potrestaný vstupom na toto políčko. Ako najjednoduchší spôsob sa ponúka strata životov a následne zastavenie alebo prejdenie prepadliska za cenu niekolkonásobnej straty životov. Bol implementovaný druhý spôsob. Pri prejdeni prepadliska aj za cenu toho, že bude robot polomŕtvy, sa pri dostatočnom množsve života môže ešte podieľať na simulácii no?? algoritmus, ktorý sa bude stále pokúšať  prestúpit prepadlisko isto zahynie.??????
\item [Robot vs. strela] Strela pri kontakte s robotom zaútoči svojím ôtokom na blizko. Následne sa robotovi na základe tohoto útoku zníži životnosť. Strela následne zmizne z hracieho pola, pretože zasiahla cieľ. Strela môže zasiahnúť aj toho, kto ju vystrelil. Je to rozumné z toho dodu, aby robot nemal tendenciu strielať všade, ale rozmýšľal.  či to neublíži aj jemu. Strela by preto mala mať väčšiu rýchlost ako robot. Inak sa môže stať, že po vystreleni správnym smerom sa robot tým smerom pohne (aby mohol sledovat obeť)  a zasiahne ho vlastna strela. Potom ale nemá zmysel použivať strelu na diaľku, pretože rýchlejšie by bolo možné použiť útok na blizko. Strelu by sa dalo použiť iba v prípade prepadliska. Ak strela bude ale dostatočne pomalá, robot sa jej ľahko vyhne a tým sa opäť stráca význam útoku na diaľku. % skontrolovat.
\item [Stena vs. strela] Strela sa  bude môcť od obyčajnej steny odrážať. Stena nie je nikdy?? alebo niekedy?? primárnym cieľom. Preto nemá zmysel, aby strela ukončila svoju dráhu pri narazeni na stenu. Jediný dôsledok by bol, že robot môže strelu vidieť a tým by bola prezradena pozícia strelca. Napriek tomu, že  strela ukonči svoju dráhu len v okamihu, ked zasiahne robota, bude možné pomocou vlastnosti strely ako dostrel??????? čistiť cestu aj za "rohom". Možné je i  umýselne mýliť  miest protivnika vyslanim strely tak, aby sa odrazila. Preto bolo rozhodnute o odrazení strely od steny.
\item[Stena vs. posuvná stena]  Robota normálna stena zastavuje a posuvná stena sa hýbe robotovym pričinenim a poskytuje mu kryt.  Je preto logicke, aby normálna stena zabraňovala pohybu aj posuvnej stene. Posúvna  stena teda na rozdiel od normálnej steny  strely neodráža, ale zastavuje.
\item[Strela vs. posuvna stena] Otázkou je, či by sa mala posuvná stena  hýbat aj pri kontakte so strelou. Posuvná stena je však primárne určená na úkryt robota a jediné, čo by mohla strela urobiť je,  vziať zaseúkryt robotovi. ked vystrelí strely.             robotovi zase ukryt zobrat ked vystreli strely. Ak by však  tento úkryt mal zmiznúť po vystrelení strely, smer strely by musel so smerom tejto posuvnej steny zvierať  tupýuhol. <TODO OBR.> To znamena, že strela by sa aj tak odrazila, pretože posuvná stena je len druh steny. Vysledok by v najhoršom prípade nemusel byť okamžitý - robot by steny stále posúval tým smerom a tak čiastočne anuloval vysledky streľby. Vysledok  by tam bol prinajmenšom neistý a ťažko využivateľný. Preto sa strela od posuvnej steny iba odráža, namiesto toho, aby ju aj posúvala.
\item [Strela vs Strela] \hfill \newline
Strela sa nijak neprofituje so zrážky s inou strelou, takže sa nič nestane. 
\end{description}
\subsection{Vytváranie máp}
Súčasťou práce bolo aj editácia a generovanie máp, nakoľko cieľom je odskúšanie algoritmu v rôznych svetoch.
Generovanie mapy pozostáva z určenia prvkov, ktoré sa budú generovať, určenie veľkosti a samotným algoritmom na umiestnenie týchto objektov. Užívateľ bude mať možnosť upraviť vygenerovanú mapu.  ak  zodpovedá  jeho predstavam.\\
Za generovateľné objekty boli vybrané  iba mapy. Roboti a strely sa nemôžu generovať, pretože robota zastupuje štartovné políčko a strely sa nepotulujú virtuálnym svetom, pokiaľ robot nezaútoči. A tak zostali štartovne políčka, obyčajné a posuvné  steny a prepadliská????No?Prepadliska!????. Obyčajné steny sú základným prvkom, s ktorými robot počita, takže tie sa generuju. \\
Prepadliská sú obtiažne generovatelné z toho dôvodu, že náhodne generované prepadliská sa môžu stať úzkym hrdlom nejakého koridoru. To znamená, že vzniknú dve oddelené časti, kam robot môže len so značnou stratou na životoch. Je možné tieto situácie nechať ošetriť uzivateľom, ale to by musel prejsť celú mapu a hľadať takéto miesta. To ale nie je užívateľsky príjemné. Je možné použiť t heuristiku, ktorá tieto miesta nájde a odstráni. Taká heuristika nie je náročná na implementovanie - stačila iba kontrola úzkych hrdiel, možných prepojeni s ostatnými miestami,\\ %tu kecam musim upravit program, ale to poviem v implementacii
Posuvné steny neboli zahrnuté do generovania. Ich generovania totiž obsahuje aj to, či sú priesvitné a posuvné a či náhodou nevytvoria  neriešiteľný virtuálny svet. Preto generovanie posuvných stien je prenechane užívateľovi.\\
Samotný algoritmus generovania vychádza z nápadu - nie zaplniť miesto objektami, ale miesto plne objektov postupne vyprázdňovať. Týmto spôsobom sa nagenerujú steny. Ďalši generovateľný objekt - prepadliská sa potom dogenerujú dodatočne prejdenim vygenerovanej kostry virtuálneho sveta a testovaním, či existencia prepadliska neodporuje vyššie  uvedeným kritériám.\\
<popis pazraveho algoritmu> % je nutne sa rozpisovat, copy & paste z posledneho vytvoru
%zaverecne zhodnotenie programu
Týmto spôsobom vygenerovaná mapa obsahuje dostatočne veľký priestor pre manevrovanie robota a súčasne sa dostatočne veľakrát podarí vygenerovať  miesta, ktoré robot použije ako kryt. Pre naše učely testovania algoritmov to postačuje. % mozno moc pesimisticke? :-) realisticke


