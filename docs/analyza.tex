\subsection{Analyza funkcie a preddefinovanou hodnotou parametru}
zavedeniu funkcie s preddefinovanou hodnotou parametre má jediný, pomerne malý dôvod. V okamihu, keď sa robot a nejaký iný objekt sa naplánujú na rovnaký čas, ten, ktorý sa naplánoval skôr, skôr tiež príde na radu (jedna z podmienok fair-play). Ak však robot zavolá funkciu, ktorá má preddefinovaný parameter, po zavolaní sa ocitne pred robotom, aj keby mali rovnaké programy a začínali rovnaký čas. To môže tomuto robotovi priniesť isté výhody, pretože sa dostane na radu skôr s predstihom minimálne 3 tickov (1 za assign a 2 za loadovanie premenných). Za ten čas sa podla tabuľky dá spraviť inštrukcia STEP a teda sa napríklad efektívne vyhnúť strele. V skratke, čím skôr sa robot dostane na radu, tým je to pre neho výhodnejsie, lebo môže skôr reagovať na udalosť a predísť následkom a tým viac sa na radu vlastne dostane. Príklad: Strela S je naplánovaná na čas \it{s1}, robot R je po rozmýšľaní 10 tickov pred strelou strelou (predpokladáme, že zavolal funkciu s preddefinovaným parametrom a inak by bol naplánpvaný maximálne 9 tickov pred S) Za ten čas sa môže 2x pohnúť, poťažne použiť inštrukciu see, zistit polohu strely a vystreliť jej smerom.
\subsection{Životnosť premenných vnútri bloku - scoping}
\indent Podobne ako v programovacích jazykoch C, Java , Delphi a pod., je použité statické zapúzdrovanie premennych. To znamená, že prístup k hodnotám, na ktorá odkazuj dané meno premennej, je len v bloku, kde bola funkcia deklarovaná a v žiadnom ďalšom podbloku premenná s rovnakým menom nesmie byť deklarovaná. Napríklad vo funkcií \\
$for (integer i = 0; i<10; i++)
{
	code;
}$
premennú i už nie je možné použiť mimo cyklu a naopak táto premenná nebola predtým deklarovaná v žiadnom v nadradených cykloch. V normálnych programovacích jazykoch je zapuzdrovanie ideálnou metódou na zprehľadnenie kódu tým, že jedno meno sa používa ako v rôzných blokoch s rovnakým meno a rozličným typom premennej, v našom prípade je ale situácia trochu zložitejšia. Ako je popísané neskôr, robota inizializovanie novej premennej niečo stojí a jej deinicializovanie tiež, takže z tohoto hľadiska na tom robot iba tratí,čo je temer vždy nežiaduce. Dôvod pre zavedenie zapúzdrovania aj v tomto prípade je, ze v okamihu, keď robot použije takúto funkciu, má to dva efekty: \\
		\begin{itemize}
		\item v pamati bude mať pochopitelne o jednu premennú viac. Keďže pamať robota nie je neobmedzená a je uživateľom definovaná na úkor iných vlastnosti(napríklad odolnosti voči zbraniam), pri kóde typu:
for (integer i = 0; i< 10; i++)
{
	//code
}
fce1();
fce2();
fce3();
..
môže pri nepodoporovanom zapúzdrovaní robotovi dojsť pamať napriek tomu, ze ďalšie použtie premennej i sa už ďalej nevyskytuje. Pri nepodporovanom zapúzdrenía súčasne výskyte premennej po danom cykle by bolo stejne akoby bola premenná definovaná v nadradenom cykle, to znamená, že až na virtuálne uvoľnenie premennej z pamäti robota by penalizácia bola úplne rovnaká.
\end{itemize}
Z tohoto dôvodu je teda zapúzdrovanie povolené. Rozlisovanie prebieha tým spôsobom, že buď so dopredu rezervuje miesto pre premenné každej funkcie v každej možnej hladine zanorenia (tažke prípadné miesto premennej by sa jednoznažne identifikovalo hĺbkou zanorenia, menom funkcie a nazvom premennej). tento spôsob ale vyžaduje generovanie obrovského množstva dát, kde len malá časť bude využívaná. Preto v tejto implementácií je pri každom volaní funkcie vygenerovaný nový podstrom, s rovnakými parametram, ale v inej hĺbke. Jedná sa vlastne o dynamické vytváranie stromu volaní funkcií. V okamihu, ked sa dojde na koniec hlavnej funkcie, vieme, že máme kompletné prehľad o tom. Tento prehľad sa však môže meniť, obzvlášt ak je volanie funkcií závislá na inštrukciách step() alebo see() robota. Keďže volanie funkcie v určitej hĺbke zanorenia je nemenne vzhľadom na to, kto funkciu volal, jednotlivé stromy (stack zostáva vždy rovnaký), sú uložené v poli rpi funkcií
