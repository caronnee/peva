Struktury na zapamatanie si instrukcii:

	Mame mnozstvo funkcii, ktore treba zavolat -> zapamatne v nejakom strome pre lahsi pritup.
Ked sa najde funkcia -> v poslednom uzle je odkaz na strukturu, ktora drzi vsetky instrukcie, ktore sa maju vykonat, defaultne null, aby sa odlisila od toho, ked bude rocnakym menom oznacena funkcia aj premenna
Chcem volat funkciu : vyhladam si  strome dane meno a zistim, ze nie je struktura NULL -> potom ju naloadujem
chcem zavolat premenny (naloadovat) -> vyhladam si v strome a zistim, ci je 'aktivna', to jest bola v danom bloku deklarovan, ak nie, tak ju v danom bloku deklarujeme t.j. 'var' nam vobec netreba, lebo akonahle nejaky identifikator pouzijeme, vytvori sa a priradi sa mu typ podla toho, co donho nacpeme.
V pripade volania pola sa zisti totez, akurat ze sa naloaduje bude cele pole alebo iba jeden jej element (takze v pripade pola load IDENT cislo)
	Preddefinovana funkcia je funkcia main, ktora je unikatna a neprepisatelna.

Co su instrukcie: 

	Najelementarnejsie akcie, ktore sa daju vykonat, t.j. napriklad vyzdvihnutie premennej, pricitanie, ulozenie a pod.
	Poznam dva typy premennych 
		- nepotrebuju nic (ako napriklad move, shoot, tie si svoje parametre zoberu zo 
	stacku, ktory je oddelene a obsahuje len aktualne hodnoty a mena tych premennch, co boli naloadovane), pretoze tom ,
	co potrebuje, si musi dynamicky naloadovat(hodnoty inych premenncyh) 
		- maju staticke parametre (napriklad aku funkciu zavolat alebo aky premennu naloadovat
	za povsimnutie stoji, ze u instrukcii teda potrebujem iba cislo, kam by sa eventualne skocilo, samotnu instrukciu a 
	string, potazne cislo. Toto cislo mozem zamienat s cislom u labelu, nicmene to asi nebude uplne fajn, jelikoz v pripade 
	rozsirenia o labely to bude robit neplechu
		-jump
		-clean_local_variable - po kazdom skonceni sa vymaze premenna, ktora bola prvy krat pouzite v tomto bloku, aby sa zamedzilo zbytocnemu hlteniu pamate

Instrukcie

	Vsetky operacie s cislami + vsetky funkcie -> nepotrebuju nic pridavne, vsetko si beru zo stacku
	if, else, while, repeat, for -> potrebuju vediet, kam skocit -> pridavny int
	loadovanie premennych a ich ulozenie -> string, potrebuju vediet, co loaduju
	zistovanie vlastnosti objektu -> nepotrebuje nic dalsie, pretoze nerie meno z toho, co je pred bodkou.(see(3).IsMoving())
	Create_object - potrebuje string, co ma aktivovat / vytvorit.

Uchovavanie premenych:
	Strom, vytvori sa pri inite a nemaze sa, pokial nepresiahne urcitu velkost, ktora sa pocita externe. V pripade, ze to teda presiahne, sa vycisti-> 
dealokuju sa vsektky prvky, co ni su aktivne, a dalej sa checkuje, ci to pomohlo. Ak nie, zmaze sa nekolko nahodnych premennych( asi primarne funkcii
) -> v pripade pristupu na takuto funkciu/premennju ju samozrejme zase vytvori/ okopiruje. Dovod, pre ktory to tu davam nie je ani tak v tom, 
ze dojde pamat, ako omedzenie pre bota, ze si toho nesmie pamat prilis moc.
	Pri pristupe na tieto premenne bud bot skonci alebo (lepsie) sa mu dostane neinicializovana hodnota. To, co dana premenna existuje a nepristupuje sa
na nu nepravom, sa kontroluje uz pri nacitani kodu bota, takze v pripade, ze sa nenajde v dotycnom strome za behu programu, neznamena, ze nie je deklarovana.
V tomto pripade je sice diskutabilne pouzitie slovicka 'var', pretoze aj keby tam nebolo, tak by sa premenne v strome vytvarali, ale ma to zmysel pre vyuzitie pre mainom a aj v tom  
	U kazdeho uzlu je napisane, ci je premenna aktivna ( podal toho sa pozna, aky typ to je ( point, object alebo integer) -> globalna funkcia bude aktivna stale, velkost zanorenia, v ktorom bola tato premenna vytvorena (dolezite pre mazanie lokalnych premennych), pred kazdym blokom bude specialna intrukcia, ktora nestoji vlastne nic, a to zvys_zanorenie a zniz_zanorenie;
	rozoznavanie vnorenej premennej -> v pripade, ze rekurzivne volam istu funkciu, mala by sa mi predlzit jedna vetva a preto nie je problem s volanim 
for, repeat sa v tomto ohlade rataju ako funkcie, lebo sa nimi nasleduje blok
v pripade skoncenia bloku sa vsetky premenne tu deklarovane musia znehodnotit -> to sa spravit tak, ze ako poslednu instrukciu po bloku este pridam instrukciu 'delete_local', ktora od korena danej funkcie prejde vsetky premenne, ktore sa vytvorili s indexom 'vnorenia', aky je maximalne nastaveny (pri kazdom zaciatku bloku sa zvysuje, po konci znizuje, udrzuje sa ako globalna premenna)

strom sa bude dotvarat aj pocas behu bota -> pri volani nejakej uzivtalom definovanej funkcie sa do stromu prida (ak tam este nie je) prefix aktualnej funkcie, v ktorej sme (okrem main) a deep_copy stromceka funkcie-> presne kopia toho stromu.
x

Ako sa hlada premenna, ktoru ma loadovat -> bude je to lokalna vo funkcii alebo globalna uplne -> bud zacnem uplne od korena a idem po strome alebo zacnem vnutri funkcie.

//-> centralny pocitac bude spracovavat iba akcie a odosielat graficky vysledok, jelikoz akcie botov by mali prebiehat pomerne paralelne
keby sa to robilo na jednom stroji, mala by som frontu poziadavkov na plochu, co sa deje -> nie zly napad, ale trebalo by pouzit viacero threadov, aby sa to zrychlilo a zachovala rychlost botov
Tym sa myslim, ze kopirovanie takehoto stromckea by stalo bota niekolko casu, ale nie realneho, aby to nebolo zavisle na procesore a pamati, zatial aleno moze robit nieco ine ony bot
problem s tym, ze viacero threadov alokuje viacero pamate?
Dalsi problem, ze sa moze obcas stat, ze to cele kompletne zamrzne -> zase na druhej strane, vskutku to bude vyzerat, ze boti premyslaju;)

Rekurzia:
pocet rekurzii radsej bude odmedzeny tym sposobom, ze bude obmedzena velkost stacku instrukcii -> povedzme, ze 1000 instrukcii v hlavnom kode, tym sa omedzi rekurzia a nebude sa vsetko pchat do globanych premennych, jelikoz te by zabrali 

samotne prevadzanie instrukcii:
stack bude vzdy naalokovany na maximalnu moznu velkost. najskor sa do stacku prekopiruje kompletne cela funkcia 'main' a zacnu sa vykonavat instrukcie. Pokial store/load
V pripade, ze sa bude odovzdavat aj parameter referenciou, bude na konci kazej uzivatelom definovanej funkcie alebo procedury dalsia instrukcia, ktora hovori, zev pripade,ze boli parametre varovane, nech sa zisti, ako boli volane potom tam daj hodnotu.
